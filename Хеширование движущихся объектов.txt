Хеширование движущихся объектов
Жексуан Сонг
Факультет информатики
Университет Мэриленда
Колледж Парк, Мэриленд 20742
zsong@cs.umd.edu

Ник Россопулос
Факультет информатики и Институт передовых компьютерных наук Университета Мэриленда
Колледж Парк, Мэриленд 20742
nick@cs.umd.edu

19 мая 2000 года

Аннотация

В реальной жизни объекты относятся как к пространству, так и ко времени. Объекты, меняющие свое положение в течение продолжительного времени, называются движущимися. С развитием беспроводной связи и технологий позиционирования становится необходимым хранить и индексировать такие объекты в базе данных. Ввиду сложности проблемы многие сугубо пространственные индексные структуры не способны индексировать большой объём движущихся объектов в базще данных.
В этой статье мы предлагаем абсолютно новую идею, основанную на методе хеширования. Так как стало возможным заново индексировать все объекты каждый период времени, мы размещаем их в "корзинах". Если объект перемещается в пределах корзины, база данных не меняется. Использование этой техники значительно снижает количество обновлений базы данных - процедура индексирования становится приемлемой для выполнения. Также мы расширяем структуру предыдущей системы, представляя фильтрующий слой между сборщиком информации о местоположении и базой данных. Кроме того, представлены четыре разных метода, основанных новой системе. С целью оценить различные аспекты наших индексных техник были проведены тесты производительности, и их итоги приведены в данной статье.

1. Введение
Традиционно, системы управления базой данных применяют "статичную" модель, предполагающую, что данные, размещённые в базе, остаются неизменными, пока не будут изменены явно через операцию обновления. Такая модель приемлема, если свойства обхектов меняются дискретно или не меняются вовсе. Однако, в реальной жизни множество объектов постоянно меняют свойства. Одно приложение предназначено для поддержки базы данных в системе контроля за воздушным движением. В этом случае в роли движущихся объектов выступают самолёты. Их положение постоянно изменяется. Одно из возможных решений для "статичной" модели мы назвали "наивным": обновлять информацию о положении объектов через определённый промежуток времени. Ввиду больших затрат на обновление это решение представляется неэффективным.
С развитием систем позиционирования таких как GPS, технологий беспроводной связи и электроники, стало технически возможно и необходимо отслеживать и записывать местоположение большого количества движущихся объектов. В соответствии с [SJL+99], рынок мобильных телефонов ожидает более чем 500 миллионов пользователей телефонов к 2002 году и миллиард к 2004, а мобильные телефоны станут беспроводными устройствами для доступа к интернету. Отслеживание положения таких устройств может существенно улучшить качество услуг связи. Появление более сложных систем баз данных становится крайне необходимо.
Новая база данных, которая работает с геометрическими изменениями во времени, называется пространственно-временной базой данных. Проблемы этой новой сферы привлекают внимание как академического, так и производственного сообществ. [WCD+98] представил модель Moving Objects Spatio-Temoporal (MOST) и язык  (FTL) для запроса текущего и будущего положения движущихся объектов; [TJ98] предлагает концептуальную компонентную модель для разработки пространственно-временных приложений; Нассименто в [NST99] представляет алгоритм GSTD ("Generate Spatio-Temporal Data" ("Генерирование пространственно-временных данных")), который генерирует множества движущихся точек или прямоугольников, следующих расширенному множеству распределений. Искуственно созданные алгоритмом GSTD данные используются для оценки различных методов индексирования. Система Arc View GIS [ArcV98] уже поддерживает отслеживание мобильных объектов и обработку связанных с ними запросов.
Эта статья сконцентрирована на методах индексирования большого числа перемещающихся объектов без необходимости частого обновления базы данных. Главным образом будет обсуждаться как быстро отвечать на различные запросы о текущем положении объекта, так как такие запросы представляют собой основную операцию для других запросов, таких как  запросы ближайших соседей [CG99, SK98]. Так как ответ основан на текущей информации, расположенной в базе, нужно, чтобы эта информация была как можно точнее. Основная задача - избежать недопустимо больших накладных расходов на обновление.
"Наивное решение" отказывает с ростом количества движущихся объектов. Допустим, система управления базой данных может справиться с Nt операциями в секунду (в большинстве случаев Nt менее 1000). Число объектов - No. Через каждый промежуток времени информация о положении требует обновления. Таким образом, требуется No операций обновления на каждый период. Это займёт по меньшей мере No/Nt секунд. Если No невелико, например, несколько тысяч в случае с управлением воздушным движением, "наивное решение" довольно не плохо. Однако, если No велико, к примеру, несколько миллионов для отслеживания движения автомобилей или даже больше, в случае с мобильной связью, каждое обновление требует десятков минут и более. Это значит, что позиционная информация объекта, размещённая в базе данных, может устареть на десять минут и более! Результат запроса таких данных представляется неприемлемым.
Альтернативный подход [KGT99, SJL+99] - это представление позиции перемещающихся объектов в виде функции от времени f(t) и обновление базы данных только тогда, когда параметры этой функции изменились. В большинстве случаев используются линейные функции ввиду своей простоты. В любое данное время to можно найти положение каждого объекта путём вычисления функции f(to). Такой подход также может прогнозировать будущее положение объектов. Он может хорошо сработать на каких-либо научных базах данных, где путь каждого объекта известен заранее. Однако, в реальной жизни очень сложно найти функцию, описывающую активность объектов. Или же параметры f должны меняться очень часто. Например, мы решили использовать линейную функцию для описания активности пользователя мобильного телефона. Каждый раз когда он меняет направление или скорость движения, создаётся запрос обновления базы данных.  Такие изменения могут происходить постоянно. Так что этот метод по-прежнему требует слишком много обновлений базы данных. Ещё один недостаток заключается в том, что после некоторого количества обновлений параметров требуется произвести достаточно сложные вычисления, чтобы найти текущее положение каждого объекта. Это значительно ухудшит эфективность процедуры запроса.

Наш вклад в этой статье включает в себя следующее:

- Мы предлагаем новую идею, основанную на технике хешировния. Каждый объект помещён в "корзину". Только лишь когда объект переходит в новую корзину, база данных производит обновление. Эта техника существенно уменьшает число обновлений базы данных, что позволяет системе хранить и индексировать большое количество перемещающихся объектов. 
- Мы представляем новую структуру системы. Между сборщиком информации о положении и базой данных мы добавили новую прослойку и назвали её "позиционная пред-исполнительная часть". Эта прослойка может фильтровать  большинство запросов обновления базы данных, основываясь на правилах, опредедённых в начале.
- Мы выделяем четыре различных метода. Первый разделяет пространство на маленькие "корзины". Второй допускает пересечения корзин, это снижает количество обновлений базы данных, сформированных зигзагообразными движениями объектов. Третий метод позволяет динамическое обновление корзин, это повышает эффективность размещения при неравномерном распределении объектов. И последний, четвёртый, метод совмещает в себе лучшие стороны второго и третьего методов. В экспериментальном разделе мы также приводим некоторые рекомендации по по выбору метода.

Во второй части обсуждается соответствующая работа в области пространственно-временной базы данных. Затем, в третьей части, мы излагаем основную идею наших методов, а также новую систему структур данных, необходимых для воплощения идеи. В следующей части мы представляем четыре особых метода. Результаты экспериментов приведены в части 5, а последняя часть содержит выводы и направления дальнейших исследований.

2. Связанная работа
В последнее время была проделана большая работа по индексированию положения движущихся объектов. Эти работы по большей части сконцентрированы на точечных данных. Связанная работа может быть разделена на две категории в зависимости от информации, размещённой в базе данных.
Первый подход подразумевает размещение информации о положении перемещающихся объектов, полученной путём периодичной выборки. Движение объектов между двумя позициями выборки описывается с использованием интерполяции. Интерполяция может быть как линейной, являющийся простейшей, так и полиномиальной сплайновой [BBB87]. Затем движение одного объекта в d-мерном пространстве описывается как страектория в (d+1)-мерном пространстве, включающем время. [TUW98]. Методы, соответствующие этому подходу главным образом сфокусированы на индексировании траекторий.

В [PTJ99] авторы определяют метод, основанный на R-дереве и названный STR-дерево. Там используется способ линейной интерполяции, так что траектория объекта представляется в виде множества отрезков. В STR-дереве при выполнении операции вставки отрезки внутри одной и той же траектории наиболее вероятно будут размещены вместе. Позже, в [PTJ00] эти же авторы предлагают другую структуру, TB-дерево, которая сохраняет траектории целиком. Авторы утверждают, что эти два новых дерева работают лучше при индексации движущихся объектов, чем семейство традиционных R-деревьев.
Так как этот подход использует интерполяцию, чтобы описать движение объекта между двумя выбранными точками, могут появиться некоторые неопределённости. Волфсон и др. [WCD+98] рассматривают проблему неточности и в настоящее время DBMS может обеспечить связность запросов. Пфосер и Дженсен отметили в [PJ99], что при ограничении скорости возможное положение объекта между двумя выбранными позициями должно быть "затмением", а не просто отрезком. А запросы должны этот фактор учитывать.
Недостатком этого подхода является то, что при большом количестве объектов после каждой выборки может происходить слишком много операций с базой данных. Например, в STR-дереве каждая выборка будет генерировать n вставок отрезков в базу, где n - это количество объектов. Ввиду ограниченности базы данных выборка не может происходить очень часто для большого n. Это значительно увеличит фактор неточности и вызовет неоднозначность запроса.
Второй подход же использует функцию для описания перемещения объекта и размещает эту функцию в базе данных. Пусть, например, в одномерном пространстве в момент времени to позиция объекта - xo, и объект движется с постоянной скоростью v. В любой момент времени t позиция объекта может быть описана как f(t) = xo + v(t - to). Если просто поместить f в базу данных, не будет нужды делать обновление базы данных до тех пор, пока объект не изменит скорость.
В [KGT99] авторы используют линейные функции для описания траекторий объектов. Так как в пространственной базе данных весьма непросто индексировать непрерывную линию, авторы отображают линию в точки на двойной плоскости. Такое преобразование позволяет сформулировать задачу более интуитивно понятно.  Однако, следует отметить, что запрос приличного диапазона преобразуется к многоугольнику в двойном пространстве. Это чуть усложняет запрос.
Систла и др. предлагают модель данных, которая называется MOST в [SWC+97]. В этой модели каждый объект имеет специальный атрибут - функцию. Это функция от времени. Без осуществления явного обновления позиция каждого объекта может быть найдена путём комбинирования этого атрибута с другими стандартными атрибутами (такими как позиция и время). Модель также позволяет DBMS обрабатывать мгновенные, продолжительные и постоянные запросы.
TPR-дерево - структура, основанная на R*-дереве [SJL+99] - использует очень похожую идую. В этом дереве позиция перемещающегося объекта представляется ссылкой на позицию и соответствующим вектором скорости. Вектор скорости может рассматриваться как атрибут-функция в MOST. TPR-дерево также поддерживает эффективную обработку запросов текущего и прогнозируемого положения движущихся объектов.
Как обсуждалось в первом разделе, этот подход может частично решить проблему обновления базы данных, если движение объектов происходит по какому-либо закону (как частицы в научных экспериментах). В реальной жизни же невозможно отыскать простую функцию, которая описывала бы движение людей. Даже скорость автомобиля на трассе может меняться очень часто. По определению, каждое изменение скорости вызывает обновление базы данных. Поэтому общее число обновлений всё ещё велико.

3. Техники хеширования
Этот раздел представляет основную идею техники хеширования и соответствующую структуру данных. Главная цель нашего метода - уменьшить число обновлений базы данных таким образом, чтобы система имела возможность размещать и индексировать большое количество движущихся объектов. 
Основное отличие между движущимися объектами и неподвижными заключается в том, что положение движущихся объектов часто меняется. В базе данных, если мы хотим отслеживать точное положение перемещающихся объектов, неизбежным становится большое количество обновлений базы данных. В связи с этим мы предлагаем "размытую" идею: не стоит обновлять положение объектов в базе до тех пор, пока они не отклонятся от своего первоначального положения достаточно сильно. К примеру, нам надо отследить перемещение путешественника в Вашингтоне. Пусть в момент времени to он находится возле монумента Вашингтона, который есть в нашей базе. Он может ходить вокруг него всё время, однако, мы не будем сохранять эти перемещения, пока он не удалится достаточно от изначальной позиции, скажем, в момент времени t1, когда он будет находиться на капитолийском холме. Любые движения между to и t1 попросту не будут отображаться в нашу базу данных.
Появляется некая неопределённость в запросах. Например, если мы хотим найти положение объекта O прямо сейчас, результат запроса базы данных будет чем-то вроде "объект O в данный момент находится в области, близкой к po, где po - это информация о положении, размещённая в базе". Также в диапазонных запросах: пусть дан диапазон R. Результат содержит две части: какие-то объекты находятся точно в диапазоне запроса, а какие-то потребую дальнейшего уточнения. [Рис. 1: структура иного метода]
С целью решить эту проблему мы разработали целую новую структуру. Перед тем, как мы её представим, давайте сначала посмотрим, на что похожи структуры иных методов. На рисунке 1 показан общий принцип. В традиционных структурах движущиеся объекты посылают свою самую последнюю информацию (положение, функцию, скорость и т. д.) напрямую в базу данных. Получив такую информацию, база выполняет соответствующие обновления. База данных всегда хранит последний статус каждого объекта, и ответы на запросы основываются на этой информации. База данных может использовать различные индексные структуры (STR-дерево, TPR-дерево), чтобы ускорить процедуры обновления и обработки запросов.
Структура нашего метода (рис. 2), названная техникой хеширования, работает по-разному. Сначала представим хеш-функцию, которая получает в качестве входных данных текущий статус объекта. Исходя из этой функции система способна найти, к какой корзине принадлежит каждый объект. База данных хранит только информацию о корзинах: сколько объектов в корзине, в какой корзине каждый объект находится в настоящее время. Между базой данных и движущимися объектами мы добавили набор фильтров, который называется "позиционные пред-исполнительные части (LP)". Каждая такая часть следит за маленьким подмножеством объектов и использует массив для хранения последнего статуса этих объектов.
[Рис. 2: структура техники хеширования]
Когда объект меняет своё местоположение и генерирует запрос обновления, запрос сначала направляется в соответствующую LP. LP локально обновляет статус объекта, затем она применяет хеш-функцию к последнему статусу объекта, чтобы посмотреть, находится ли объект в той же корзине. Если да, запрос просто игнорируется. Для тех объектов, которые перемещаются в новую корзину, запросы преобразуются в запросы обновления корзины и посылаются в базу данных. 
В нашей структуре весьма большая работа базы данных проделывается в LP. Такой подход обладает множеством преимуществ. Во-первых, каждая LP просматривает малое количество объектов, и LP работают параллельно. Когда объекты обновляют статус, система может сразу же закончить соответствующее изменение. Поэтому становится возможным делать выборки с большей частотой. Во-вторых, система очень хорошо масштабируется. Когда количество объектов растёт, нужно просто добавить больше LP. И нет необходимости производить значительные изменения в базе данных. Эта разработка делает возможной обработку большого числа объектов.
Каждая корзина в базе данных содержит все объекты, которые имеют одно и то же значение хеш-функции. Иногда корзина может рассматриваться как регион в рабочем пространстве. Регион - это объединение всех возможных положений, которые имеют одинаковое значение хеш-функций.
[Рис. 3: хеш-функция разбила рабочее пространство на 16 регионов]

Пример 3.1. Пусть двухмерное рабочее пространство - это квадрат [0,1]^2. Выбранная хеш-функция: f(pxy) = (int(y*4))*4 + int(x*4), где (x,y) - это текущее положение. Использование этой функции разбивает рабочее пространство на 16 регионов (см. рис. 3). В этом случае корзина 0 может рассматриваться как регион A, потому что если объект в регионе A, и если применить к нему хеш-функцию, получим, что объект должен находиться в корзине 0.

Как говорилось ранее, появляется некоторая неточность, если просто использовать базу данных для ответа на запросы. В нашей же структуре нижеследующие части разработаны для того, чтобы минимизировать или вовсе исключить неточности. Когда приходит диапазонный запрос, сначала он посылается в часть "трансформации запроса" (QT). QT преобразует диапазонный запрос в запрос корзины. К примеру, предположим, что запрос выглядит так: "Найти все корзины, пересекающиеся с R". Каждая корзина в базе данных имеет один из трёх следующих статусов:

1. Корзина не пересекается с диапазоном запроса. В этом случае объекты корзины не могут быть в диапазоне запроса.
2. Диапазон запроса перекрывает корзину. Значит, объекты корзины должны быть в диапазоне запроса.
3. Корзина пересекается с диапазоном запроса. Этот случай - кое-что посложнее. Пока база данных не имеет возможности различить, какие объекты корзины попадают в диапазон, а какие нет. Есть два возможных пути. Первый: с помощью статистики дать приблизительный результат. В этой облати было проделано много работы [PIH+96, APR99]. Второй ищет все объекты в корзине и отправляет их id в LP. Затем LP проверяют последнюю позицию объектов, чтобы увидеть, действительно ли они находятся в диапазоне запроса, а затем отправляют результат. Мы применяем последний подход.

На рисунке 2 курсивом показана процедура индексирования, а жирным - процедура запроса.

Пример 3.2. (традиционная структура) Наша структура в состоянии использовать одну LP, чтобы смоделировать традиционное решение. Определим хеш-функцию f(p) = 0 для каждого объекта p. База данных имеет только одну корзину, и она пересекается с любым диапазоном запроса. В соответствии с нашей разработкой, LP перепроверяет каждый объект и сообщает результат. При таком моделировании наша база данных становится бесполезной, а всю работу выполняет LP.

Разработанная нами структура очень гибка. Выбирая разные хеш-функции, мы получаем разные методы. В следующем разделе мы представим четыре различных метода, основанных на этой структуре.