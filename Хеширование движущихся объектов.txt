Хеширование движущихся объектов
Жексуан Сонг
Факультет информатики
Университет Мэриленда
Колледж Парк, Мэриленд 20742
zsong@cs.umd.edu

Ник Россопулос
Факультет информатики и Институт передовых компьютерных наук Университета Мэриленда
Колледж Парк, Мэриленд 20742
nick@cs.umd.edu

19 мая 2000 года

Аннотация

В реальной жизни объекты относятся как к пространству, так и ко времени. Объекты, меняющие свое положение в течение продолжительного времени, называются движущимися. С развитием беспроводной связи и технологий позиционирования становится необходимым хранить и индексировать такие объекты в базе данных. Ввиду сложности проблемы многие сугубо пространственные индексные структуры не способны индексировать большой объём движущихся объектов в базще данных.
В этой статье мы предлагаем абсолютно новую идею, основанную на методе хеширования. Так как стало возможным заново индексировать все объекты каждый период времени, мы размещаем их в "корзинах". Если объект перемещается в пределах корзины, база данных не меняется. Использование этой техники значительно снижает количество обновлений базы данных - процедура индексирования становится приемлемой для выполнения. Также мы расширяем структуру предыдущей системы, представляя фильтрующий слой между сборщиком информации о местоположении и базой данных. Кроме того, представлены четыре разных метода, основанных новой системе. С целью оценить различные аспекты наших индексных техник были проведены тесты производительности, и их итоги приведены в данной статье.

1. Введение
Традиционно, системы управления базой данных применяют "статичную" модель, предполагающую, что данные, размещённые в базе, остаются неизменными, пока не будут изменены явно через операцию обновления. Такая модель приемлема, если свойства обхектов меняются дискретно или не меняются вовсе. Однако, в реальной жизни множество объектов постоянно меняют свойства. Одно приложение предназначено для поддержки базы данных в системе контроля за воздушным движением. В этом случае в роли движущихся объектов выступают самолёты. Их положение постоянно изменяется. Одно из возможных решений для "статичной" модели мы назвали "наивным": обновлять информацию о положении объектов через определённый промежуток времени. Ввиду больших затрат на обновление это решение представляется неэффективным.
С развитием систем позиционирования таких как GPS, технологий беспроводной связи и электроники, стало технически возможно и необходимо отслеживать и записывать местоположение большого количества движущихся объектов. В соответствии с [SJL+99], рынок мобильных телефонов ожидает более чем 500 миллионов пользователей телефонов к 2002 году и миллиард к 2004, а мобильные телефоны станут беспроводными устройствами для доступа к интернету. Отслеживание положения таких устройств может существенно улучшить качество услуг связи. Появление более сложных систем баз данных становится крайне необходимо.
Новая база данных, которая работает с геометрическими изменениями во времени, называется пространственно-временной базой данных. Проблемы этой новой сферы привлекают внимание как академического, так и производственного сообществ. [WCD+98] представил модель Moving Objects Spatio-Temoporal (MOST) и язык  (FTL) для запроса текущего и будущего положения движущихся объектов; [TJ98] предлагает концептуальную компонентную модель для разработки пространственно-временных приложений; Нассименто в [NST99] представляет алгоритм GSTD ("Generate Spatio-Temporal Data" ("Генерирование пространственно-временных данных")), который генерирует множества движущихся точек или прямоугольников, следующих расширенному множеству распределений. Искуственно созданные алгоритмом GSTD данные используются для оценки различных методов индексирования. Система Arc View GIS [ArcV98] уже поддерживает отслеживание мобильных объектов и обработку связанных с ними запросов.
Эта статья сконцентрирована на методах индексирования большого числа перемещающихся объектов без необходимости частого обновления базы данных. Главным образом будет обсуждаться как быстро отвечать на различные запросы о текущем положении объекта, так как такие запросы представляют собой основную операцию для других запросов, таких как  запросы ближайших соседей [CG99, SK98]. Так как ответ основан на текущей информации, расположенной в базе, нужно, чтобы эта информация была как можно точнее. Основная задача - избежать недопустимо больших накладных расходов на обновление.
"Наивное решение" отказывает с ростом количества движущихся объектов. Допустим, система управления базой данных может справиться с Nt операциями в секунду (в большинстве случаев Nt менее 1000). Число объектов - No. Через каждый промежуток времени информация о положении требует обновления. Таким образом, требуется No операций обновления на каждый период. Это займёт по меньшей мере No/Nt секунд. Если No невелико, например, несколько тысяч в случае с управлением воздушным движением, "наивное решение" довольно не плохо. Однако, если No велико, к примеру, несколько миллионов для отслеживания движения автомобилей или даже больше, в случае с мобильной связью, каждое обновление требует десятков минут и более. Это значит, что позиционная информация объекта, размещённая в базе данных, может устареть на десять минут и более! Результат запроса таких данных представляется неприемлемым.
Альтернативный подход [KGT99, SJL+99] - это представление позиции перемещающихся объектов в виде функции от времени f(t) и обновление базы данных только тогда, когда параметры этой функции изменились. В большинстве случаев используются линейные функции ввиду своей простоты. В любое данное время to можно найти положение каждого объекта путём вычисления функции f(to). Такой подход также может прогнозировать будущее положение объектов. Он может хорошо сработать на каких-либо научных базах данных, где путь каждого объекта известен заранее. Однако, в реальной жизни очень сложно найти функцию, описывающую активность объектов. Или же параметры f должны меняться очень часто. Например, мы решили использовать линейную функцию для описания активности пользователя мобильного телефона. Каждый раз когда он меняет направление или скорость движения, создаётся запрос обновления базы данных.  Такие изменения могут происходить постоянно. Так что этот метод по-прежнему требует слишком много обновлений базы данных. Ещё один недостаток заключается в том, что после некоторого количества обновлений параметров требуется произвести достаточно сложные вычисления, чтобы найти текущее положение каждого объекта. Это значительно ухудшит эфективность процедуры запроса.

Наш вклад в этой статье включает в себя следующее:

- Мы предлагаем новую идею, основанную на технике хешировния. Каждый объект помещён в "корзину". Только лишь когда объект переходит в новую корзину, база данных производит обновление. Эта техника существенно уменьшает число обновлений базы данных, что позволяет системе хранить и индексировать большое количество перемещающихся объектов. 
- Мы представляем новую структуру системы. Между сборщиком информации о положении и базой данных мы добавили новую прослойку и назвали её "позиционная пред-исполнительная часть". Эта прослойка может фильтровать  большинство запросов обновления базы данных, основываясь на правилах, опредедённых в начале.
- Мы выделяем четыре различных метода. Первый разделяет пространство на маленькие "корзины". Второй допускает пересечения корзин, это снижает количество обновлений базы данных, сформированных зигзагообразными движениями объектов. Третий метод позволяет динамическое обновление корзин, это повышает эффективность размещения при неравномерном распределении объектов. И последний, четвёртый, метод совмещает в себе лучшие стороны второго и третьего методов. В экспериментальном разделе мы также приводим некоторые рекомендации по по выбору метода.

Во второй части обсуждается соответствующая работа в области пространственно-временной базы данных. Затем, в третьей части, мы излагаем основную идею наших методов, а также новую систему структур данных, необходимых для воплощения идеи. В следующей части мы представляем четыре особых метода. Результаты экспериментов приведены в части 5, а последняя часть содержит выводы и направления дальнейших исследований.

2. Связанная работа
В последнее время была проделана большая работа по индексированию положения движущихся объектов. Эти работы по большей части сконцентрированы на точечных данных. Связанная работа может быть разделена на две категории в зависимости от информации, размещённой в базе данных.
Первый подход подразумевает размещение информации о положении перемещающихся объектов, полученной путём периодичной выборки. Движение объектов между двумя позициями выборки описывается с использованием интерполяции. Интерполяция может быть как линейной, являющийся простейшей, так и полиномиальной сплайновой [BBB87]. Затем движение одного объекта в d-мерном пространстве описывается как страектория в (d+1)-мерном пространстве, включающем время. [TUW98]. Методы, соответствующие этому подходу главным образом сфокусированы на индексировании траекторий.

В [PTJ99] авторы определяют метод, основанный на R-дереве и названный STR-дерево. Там используется способ линейной интерполяции, так что траектория объекта представляется в виде множества отрезков. В STR-дереве при выполнении операции вставки отрезки внутри одной и той же траектории наиболее вероятно будут размещены вместе. Позже, в [PTJ00] эти же авторы предлагают другую структуру, TB-дерево, которая сохраняет траектории целиком. Авторы утверждают, что эти два новых дерева работают лучше при индексации движущихся объектов, чем семейство традиционных R-деревьев.
Так как этот подход использует интерполяцию, чтобы описать движение объекта между двумя выбранными точками, могут появиться некоторые неопределённости. Волфсон и др. [WCD+98] рассматривают проблему неточности и в настоящее время DBMS может обеспечить связность запросов. Пфосер и Дженсен отметили в [PJ99], что при ограничении скорости возможное положение объекта между двумя выбранными позициями должно быть "затмением", а не просто отрезком. А запросы должны этот фактор учитывать.
Недостатком этого подхода является то, что при большом количестве объектов после каждой выборки может происходить слишком много операций с базой данных. Например, в STR-дереве каждая выборка будет генерировать n вставок отрезков в базу, где n - это количество объектов. Ввиду ограниченности базы данных выборка не может происходить очень часто для большого n. Это значительно увеличит фактор неточности и вызовет неоднозначность запроса.
Второй подход же использует функцию для описания перемещения объекта и размещает эту функцию в базе данных. Пусть, например, в одномерном пространстве в момент времени to позиция объекта - xo, и объект движется с постоянной скоростью v. В любой момент времени t позиция объекта может быть описана как f(t) = xo + v(t - to). Если просто поместить f в базу данных, не будет нужды делать обновление базы данных до тех пор, пока объект не изменит скорость.
В [KGT99] авторы используют линейные функции для описания траекторий объектов. Так как в пространственной базе данных весьма непросто индексировать непрерывную линию, авторы отображают линию в точки на двойной плоскости. Такое преобразование позволяет сформулировать задачу более интуитивно понятно.  Однако, следует отметить, что запрос приличного диапазона преобразуется к многоугольнику в двойном пространстве. Это чуть усложняет запрос.
Систла и др. предлагают модель данных, которая называется MOST в [SWC+97]. В этой модели каждый объект имеет специальный атрибут - функцию. Это функция от времени. Без осуществления явного обновления позиция каждого объекта может быть найдена путём комбинирования этого атрибута с другими стандартными атрибутами (такими как позиция и время). Модель также позволяет DBMS обрабатывать мгновенные, продолжительные и постоянные запросы.
TPR-дерево - структура, основанная на R*-дереве [SJL+99] - использует очень похожую идую. В этом дереве позиция перемещающегося объекта представляется ссылкой на позицию и соответствующим вектором скорости. Вектор скорости может рассматриваться как атрибут-функция в MOST. TPR-дерево также поддерживает эффективную обработку запросов текущего и прогнозируемого положения движущихся объектов.
Как обсуждалось в первом разделе, этот подход может частично решить проблему обновления базы данных, если движение объектов происходит по какому-либо закону (как частицы в научных экспериментах). В реальной жизни же невозможно отыскать простую функцию, которая описывала бы движение людей. Даже скорость автомобиля на трассе может меняться очень часто. По определению, каждое изменение скорости вызывает обновление базы данных. Поэтому общее число обновлений всё ещё велико.

3. Техники хеширования
Этот раздел представляет основную идею техники хеширования и соответствующую структуру данных. Главная цель нашего метода - уменьшить число обновлений базы данных таким образом, чтобы система имела возможность размещать и индексировать большое количество движущихся объектов. 
Основное отличие между движущимися объектами и неподвижными заключается в том, что положение движущихся объектов часто меняется. В базе данных, если мы хотим отслеживать точное положение перемещающихся объектов, неизбежным становится большое количество обновлений базы данных. В связи с этим мы предлагаем "размытую" идею: не стоит обновлять положение объектов в базе до тех пор, пока они не отклонятся от своего первоначального положения достаточно сильно. К примеру, нам надо отследить перемещение путешественника в Вашингтоне. Пусть в момент времени to он находится возле монумента Вашингтона, который есть в нашей базе. Он может ходить вокруг него всё время, однако, мы не будем сохранять эти перемещения, пока он не удалится достаточно от изначальной позиции, скажем, в момент времени t1, когда он будет находиться на капитолийском холме. Любые движения между to и t1 попросту не будут отображаться в нашу базу данных.
Появляется некая неопределённость в запросах. Например, если мы хотим найти положение объекта O прямо сейчас, результат запроса базы данных будет чем-то вроде "объект O в данный момент находится в области, близкой к po, где po - это информация о положении, размещённая в базе". Также в диапазонных запросах: пусть дан диапазон R. Результат содержит две части: какие-то объекты находятся точно в диапазоне запроса, а какие-то потребую дальнейшего уточнения. [Рис. 1: структура иного метода]
С целью решить эту проблему мы разработали целую новую структуру. Перед тем, как мы её представим, давайте сначала посмотрим, на что похожи структуры иных методов. На рисунке 1 показан общий принцип. В традиционных структурах движущиеся объекты посылают свою самую последнюю информацию (положение, функцию, скорость и т. д.) напрямую в базу данных. Получив такую информацию, база выполняет соответствующие обновления. База данных всегда хранит последний статус каждого объекта, и ответы на запросы основываются на этой информации. База данных может использовать различные индексные структуры (STR-дерево, TPR-дерево), чтобы ускорить процедуры обновления и обработки запросов.
Структура нашего метода (рис. 2), названная техникой хеширования, работает по-разному. Сначала представим хеш-функцию, которая получает в качестве входных данных текущий статус объекта. Исходя из этой функции система способна найти, к какой корзине принадлежит каждый объект. База данных хранит только информацию о корзинах: сколько объектов в корзине, в какой корзине каждый объект находится в настоящее время. Между базой данных и движущимися объектами мы добавили набор фильтров, который называется "позиционные пред-исполнительные части (LP)". Каждая такая часть следит за маленьким подмножеством объектов и использует массив для хранения последнего статуса этих объектов.
[Рис. 2: структура техники хеширования]
Когда объект меняет своё местоположение и генерирует запрос обновления, запрос сначала направляется в соответствующую LP. LP локально обновляет статус объекта, затем она применяет хеш-функцию к последнему статусу объекта, чтобы посмотреть, находится ли объект в той же корзине. Если да, запрос просто игнорируется. Для тех объектов, которые перемещаются в новую корзину, запросы преобразуются в запросы обновления корзины и посылаются в базу данных. 
В нашей структуре весьма большая работа базы данных проделывается в LP. Такой подход обладает множеством преимуществ. Во-первых, каждая LP просматривает малое количество объектов, и LP работают параллельно. Когда объекты обновляют статус, система может сразу же закончить соответствующее изменение. Поэтому становится возможным делать выборки с большей частотой. Во-вторых, система очень хорошо масштабируется. Когда количество объектов растёт, нужно просто добавить больше LP. И нет необходимости производить значительные изменения в базе данных. Эта разработка делает возможной обработку большого числа объектов.
Каждая корзина в базе данных содержит все объекты, которые имеют одно и то же значение хеш-функции. Иногда корзина может рассматриваться как регион в рабочем пространстве. Регион - это объединение всех возможных положений, которые имеют одинаковое значение хеш-функций.
[Рис. 3: хеш-функция разбила рабочее пространство на 16 регионов]

Пример 3.1. Пусть двухмерное рабочее пространство - это квадрат [0,1]^2. Выбранная хеш-функция: f(pxy) = (int(y*4))*4 + int(x*4), где (x,y) - это текущее положение. Использование этой функции разбивает рабочее пространство на 16 регионов (см. рис. 3). В этом случае корзина 0 может рассматриваться как регион A, потому что если объект в регионе A, и если применить к нему хеш-функцию, получим, что объект должен находиться в корзине 0.

Как говорилось ранее, появляется некоторая неточность, если просто использовать базу данных для ответа на запросы. В нашей же структуре нижеследующие части разработаны для того, чтобы минимизировать или вовсе исключить неточности. Когда приходит диапазонный запрос, сначала он посылается в часть "трансформации запроса" (QT). QT преобразует диапазонный запрос в запрос корзины. К примеру, предположим, что запрос выглядит так: "Найти все корзины, пересекающиеся с R". Каждая корзина в базе данных имеет один из трёх следующих статусов:

1. Корзина не пересекается с диапазоном запроса. В этом случае объекты корзины не могут быть в диапазоне запроса.
2. Диапазон запроса перекрывает корзину. Значит, объекты корзины должны быть в диапазоне запроса.
3. Корзина пересекается с диапазоном запроса. Этот случай - кое-что посложнее. Пока база данных не имеет возможности различить, какие объекты корзины попадают в диапазон, а какие нет. Есть два возможных пути. Первый: с помощью статистики дать приблизительный результат. В этой облати было проделано много работы [PIH+96, APR99]. Второй ищет все объекты в корзине и отправляет их id в LP. Затем LP проверяют последнюю позицию объектов, чтобы увидеть, действительно ли они находятся в диапазоне запроса, а затем отправляют результат. Мы применяем последний подход.

На рисунке 2 курсивом показана процедура индексирования, а жирным - процедура запроса.

Пример 3.2. (традиционная структура) Наша структура в состоянии использовать одну LP, чтобы смоделировать традиционное решение. Определим хеш-функцию f(p) = 0 для каждого объекта p. База данных имеет только одну корзину, и она пересекается с любым диапазоном запроса. В соответствии с нашей разработкой, LP перепроверяет каждый объект и сообщает результат. При таком моделировании наша база данных становится бесполезной, а всю работу выполняет LP.

Разработанная нами структура очень гибка. Выбирая разные хеш-функции, мы получаем разные методы. В следующем разделе мы представим четыре различных метода, основанных на этой структуре.

4. Хеш-функции

Этот раздел посвящён четырём различным хеш-функциям, а также здесь приведено подробное описание соответствующих методов. Первая функция основана на методе разделения пространства. После проверки произволительности обнаружилось два основных недостатка. Следующие два метода эти недостатки устраняют. Последний метод совмещает в себе две предыдущие идеи.

4.1. Метод разделения пространства на неперекрывающиеся части

Одной из главных целей использования техники хеширования является уменьшение числа обновлений базы данных. Основная идея первого метода заключается в том, чтобы разделить пространство на несколько частей. Каждая часть соответствует корзине базы данных. Только если объект покадает одну часть и переходит в другую, выполняется обновление базы. Подробности изложены ниже.
[Рис. 4: Пример движений объекта]
Первый шаг этого метода - разделение пространства на множество маленьких кусочков. На рисунке 4 рабочая область - это квадрат. Пунктирные линии делят область на 12 частей. Регион, охватываемый каждой частью рассматривается как корзина базы данных. Совершенное разделение предусматривает, что каждая корзина в любой момент времени содержит примерно одинаковое количество объектов. Однако, разделение производится заранее, и мы не располагаем данными о том, как же движутся объекты. Очень сложно сразу найти подходящее разделение. В каком-нибудь особом случае, когда, к примеру, объекты распределены равномерно и движутся хаотично, разделение на одинаковые зоны может стать почти совершенным. Если известно, что объекты двигаются возле какого-то предопределённого места, можно использовать диаграмму Вороного.
После разделения пространства следует присвоить каждой части уникальный идентификатор. Хеш-функция сейчас выглядит так: f(p) = i, где p - это объект, а i - идентификатор корзины, в которой находится p. 
Если в момент времени t объект переходит из одной части в другую (например, путь I на рисунке 4), LP, следящая за этим объектом, посылает запрос обновления в базу данных. Запрос будет похож на что-то вроде update(part_id, old_bucketid, new_bucketid, t). Иногда после смены позиции объект остаётся в прежней части (путь II на рисунке 4). И в этом случае база данных ничего не знает о подобных перемещениях.
После определения f запрос становится интуитивно понятен. В случае специального запроса база данных отправляет его LP, которая следит за объектом. LP узнаёт текущее положение объекта и выдаёт результат. Для диапазонного запроса процедура в точности такая же, как обсуждалась в предыдущем разделе. Единственное, на чём бы хотелось заострить внимание, так это на том, что информация корзины в этом случае статична, а это значит, что эта информация (размер, положение и т. д.) не меняется при однажды определённой хеш-функции f. Это позволяет нам использовать какую-либо из существующих пространственных индексных структур (R*-дерево, Quad-дерево) для того чтобы разместить корзины в базе данных. Это существенно ускорит процедуры запросов к базе данных.
Ещё одна важная проблема, требующая рассмотрения - размер частей. С одной стороны, если разделить пространство на очень большие части, объекты, вероятно, будут перемещаться, не покидая пределов одной части. Это значит, что потребуется меньше обновлений базы данных. Но в то же время при обработке диапазонного запроса корзины имеют больше шансов быть затронутыми, а это вызовет больше проверок объектов и участит связь базы данных с LP. С другой стороны, если размер корзины слишком мал, то хотя запрос и может стать быстрее (база данных в состоянии завершить большую часть обработки, и меньшее количество объектов потребует дальнейшей проверки с помощью LP), затраты на размещение корзин в базе данных значительно возрастают. База даных будет подавлена огромным количеством запросов обновления, которые могут быть неотфильтрованы LP. Для этого есть компромисс. В следующем разделе мы представим затраты на операции и подробнее обсудим, как же правильно выбрать размер частей.

4.2. Метод разделения на увеличенные части
По сравнению с другими методами, метод разделения неперекрывающихся частей порождает меньше обновлений базы данных. Однако, в таком подходе есть два недостатка. В этом и следующем подразделах они будут рассмотрены отдельно.
В методе разделения пространства на свободно перекрывающиеся части объекты, перемещающиеся зигзагообразно вдоль границы корзины, могут спровоцировать серьёзную проблему. Так как одна зона рабочей области соответствует корзине базы данных, в остальной части статьи они имеют одинаковое значение.
[Рис. 5: объект перемещается вдоль границы]
Посмотрите на рисунок 5(a). I и II - это две корзины. Объект движется вдоль их границы. Каждый раз, когда он пересекает границу (из корзины I в корзину II или наоборот), LP генерирует запрос обновления. Сначала объект в корзине I. По завершении его пути мы получаем целых восемь запросов обновления базы данных.
Чтобы разрешить эту проблему, мы чуть-чуть увеличим размер каждой корзины так, чтобы между корзинами появилась зона перекрытия. Запрос обновления будет генерироваться только если объект покинет увеличенную зону. Посмотрите на рисунок 5(b). Пунктирный и точечный квадраты представляют две увеличенные корзины. Сначала объект в корзине I (пунктирный квадрат). В точке 1 он покидает корзину I и переходит в корзину II (точечный квадрат). Затем он перемещается по корзине II и в точке 2 снова возвращается в корзину I. Теперь такой же путь объекта вызовет только два обновления базы данных. Метод разделения на увеличенные части работает следующим образом. Сначала создаются неперекрывающиеся части. Затем каждый объект хешируется в корзины в соответствии со своим изначальным положением. После этого каждая корзина увеличивается на величину б(бета). Такое увеличение означает, что центр корзины не меняется, а внешние стороны увеличиваются на малую величину б(бета). Например, если корзина покрывает прямоугольник [x0, y0][x1, y1], то после увеличения она будет покрывать прямоугольник [x0-б, y0-б][x1+б, y1+б].
На следующем шаге нужно найти хеш-функцию и поместить её в LP. Если просто использовать информацию о текущем положении объекта в качестве входных данных, возникнет проблема: когда объект перемещается в зону покрытия двух корзин, функции будет непросто решить, в какой именно корзине должен быть объект. Поэтому в этом методе мы представляем новый атрибут, который называется previous_bucketid. Этот атрибут запоминает, в какой корзине объект был доселе. Он также передаётся в хеш-функцию. Каждый отрезок времени, если объект остаётся в зоне, покрытой только одной корзиной, всё нормально. Иначе же, если зона покрывается более, чем одной корзиной, LP сперва проверяют, находился ли объект ранее в какой-нибудь из этих корзин. Если да, LP не посылают запрос обновления базе. Если нет - корзина для объекта определяется произвольно.
Последующая часть индексирования и процедура запроса такие же, как в методе разделения пространства на неперекрывающиеся части. Мы не приводим их детали здесь.

4.3. Метод хеширования с Quad-деревом.
Ещё один недостаток метода разделения пространства на неперекрывающиеся части состоит в том, что корзины не имеют возхможности менять сови размеры и положение после первоначальной установки. Нижеследующий пример демонстрирует, что иногда это может вызвать неприятности.
На рисунке 6 показан случай неравномерности. На этот раз будем использовать функцию разделения на одинаковые части: в базе появляется 16 корзин. В момент времени to все объекты находятся в верхнем левом углу. Потом они начинают движение по стрелке. В момент  t1 объекты достигают правого нижнего угла. Между to и t1 всего несколько корзин могут содержать объекты. (только в моменты to и t1). Остальные же пусты. В таком случае наша индексная структура неэффективна при диапазонном запросе.
Чтобы найти решение этой проблемы, представляем некоторые динамические структуры. Основная идея заключается в том, чтобы динамически изменять зоны покрытия каждой корзины. Если корзина содержит слишком много объектов, мы её расщипляем на несколько корзин поменьше и перераспределяем объекты старой корзины. С другой стороны, если несколько корзин содержат слишком мало объектов, мы сливаем их в одну корзину побольше и помещаем объекты вместе.
[Рис. 6: неравномерное распределение объектов]
Некоторые детали:
- В базе данных создаётся новая часть, которая называется "часть управления корзиной" (BM). BM используют пространственную индексную структуру для организации корзин. Любые изменения в корзинах (добавление или удаление объекта) повлекут за собой действия со стороны BM. BM проверяет изменение в корзине и решает, нужна ли операция расщипления (слияния).
- В качестве пространственной структуры мы использовали Quad-дерево [Sam90], так как оно имеет простую структуру и алгоритмы расщипления и слияния. В отличие от R-дерева, каждый внутренний узел Quad-дерева имеет строго четыре потомка, и ни один узел не пересекается с другим.
- В узле хранится следующая информация: зона покрытия, количество объектов внутри зоны в настоящий момент, листовой это узел или нет, указатели на потомков если не листовой, указатель на родителя, если не корень и т. д. Каждый листовой узел соответствует корзине в базе данных.
- Когда количество объектов одного листового узла превышает M, этот узел расщипляется. Пусть M - это максимальное число объектов, помещающихся на одной странице диска. Алгоритм расщипления сначала создаёт четырёх потомков, каждый из которых покрывает четверть родительской зоны. Затем алгоритм сообщает базе данных, что надо создать четыре корзины. Объекты старой корзины проверяются и помещаются во вновь созданные корзины. После этого старые корзины удаляются из базы данных, и количество объектов в новых корзинах сообщается Quad-дереву и сохраняется в новых листовых узлах. Алгоритм расщипления вызывается рекурсивно, если какая-либо из корзин-потомков всё ещё содержит объектов больше, чем M.
- Условие для слияния чуть посложнее. Если листовой узел содержит менее m объектов, нужно проверить, сколько объектов содержится в соседних узлах-братьях. Очень вероятно, что один из братьев всё ещё плотный (т.е. содержит много объектов). Так как слияние - это операция дорогостоящая, не хотелось бы слишком скоро расщиплять вновь полученную корзину. Поэтому в своём алгоритме мы определяем условие как "листовой узел содержит менее m объектов, и число объектов его родителя менее 3*M/4". Когда узел встречает это условие, его родительский узел становится новым листовым узлом. База данных создаёт новую корзину. Объекты старых корзин перемещаются в новую, и старые корзины попросту удаляются.
- Так как теперь структура корзины динамична, LP нужно знать о текущей структуре, чтобы должным образом фильтровать запросы обновления. Есть два пути. Первый метод - позволить BM транслировать индексную структуру LP после каждого её изменения. Этот метод осуществим, только если структура корзин меняется нечасто или в системе немного LP.
Другой метод - разрезать рабочее пространство на кусочки поменьше - объединения. Объединения не имеют возможности расщипляться. Каждая корзина - это множество объединений. Разделим, к примеру, двухмерную область на на 2^10 x 2^10 одинаковых по размеру объединений. По определению Quad-дерева, узлы уровня меньшего, чем 10 - это квадраты, покрывающие какие-либо объединения, и ни одно объединение не расположено в двух различных узлах Quad-дерева. LP знают размер объединения заранее. Если объект остаётся в одном и том же объединении, считается, что невозможно перелистнуть корзину. LP фильтруют движения такого типа. Если объект покидает объединение, он может либо остаться в прежней корзине, либо переместиться в другую. Для таких движений LP не могут решить, фильтровать их или нет. Поэтому LP передают их BM. BM перепроверяет запросы и выполняет повторную фильтрацию.
Алгоритм расщипления BM требует дальнейших изменений, пока он не будет подходить к последнему случаю.
При расщиплении узла нужно сделать ещё одну проверку, чтобы определить, одинакового ли размера узел и объединение. Если да, то расщипления больше не допускаются.
Код алгоритмов расщипления и слияния приведен в приложении A.
[Рис. 7: динамические структуры корзин]
На рисунке 7 показано, как выглядят корзины после применения структуры динамических корзин.
При обработке запроса его диапазон сначала попадает к BM. BM использует индексную структуру, чтобы решить, какие из корзин требуют дальнейшей проверки. Следующие этапы практически такие же, как и раньше.

4.4. Расширенный метод хеширования с Quad-деревом
Последний метод совмещает в себе идеи метода хеширования с Quad-деревом и метода разделения на увеличенные части. В этот раз мы чуть-чуть увеличим каждый узел Quad-дерева.
Сначала построим Quad-дерево, основанное на начальном распределении объектов. Затем, как в методе разделения на увеличенные части, выполним б(бета)-увеличение каждого узла (и внутренних узлов, и листовых). Благодаря простой структуре Quad-дерева после этого шага древовидная структура всё ещё в приемлемом состоянии, т. е. область каждого внутреннего узла всё ещё покрывает зоны своих потомков. 
Как в методе разделения на увеличенные части, EQ-дерево использует увеличенные узлы при индексировании. Алгоритмы индексирования, вставки и удаления почти такие же, как в методе хеширования с Quad-деревом. Поэтому не будем более говорить о них.
В этих последних четырёх подразделах мы обсудили четыре метода, основанных на нашей новой системной структуре. В следующей, экспериментальной, части мы подробнее расскажем, как выбрать подходящий размер корзины и сравним производительность этих четырёх методов на примере обработки диапазонного запроса.

5. Результаты экспериментов

Чтобы использовать достоинства описанных методов, мы написали программу-симулятор и оценили их.

5.1. 